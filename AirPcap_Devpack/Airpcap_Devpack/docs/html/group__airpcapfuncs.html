<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AirPcap: AirPcap functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="airpcap.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>AirPcap functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaf2d048644aee82a6d60d14b694d8ea75">AirpcapGetVersion</a> (PUINT VersionMajor, PUINT VersionMinor, PUINT VersionRev, PUINT VersionBuild)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a string with the API version.  <a href="#gaf2d048644aee82a6d60d14b694d8ea75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PCHAR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaa659ca1646d89a1b5e79d2496b7dedce">AirpcapGetLastError</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last error related to the specified handle.  <a href="#gaa659ca1646d89a1b5e79d2496b7dedce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList</a> (<a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> *PPAllDevs, PCHAR Ebuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the list of available devices.  <a href="#ga4f2d7dad3d18925221a312b24372d604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga2ee2864654ca3fbd1f5c3a3e72efa992">AirpcapFreeDeviceList</a> (<a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> PAllDevs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a list of devices returned by <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Returns the list of available devices.">AirpcapGetDeviceList()</a>.  <a href="#ga2ee2864654ca3fbd1f5c3a3e72efa992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga69a24296462970dd8915aae1039b2bb3">AirpcapOpen</a> (PCHAR DeviceName, PCHAR Ebuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens an adapter.  <a href="#ga69a24296462970dd8915aae1039b2bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga75106eb2f2ce0a528b37bbc5b90f63af">AirpcapClose</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes an adapter.  <a href="#ga75106eb2f2ce0a528b37bbc5b90f63af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaece6915d2a521e566da9234eb74c0543">AirpcapGetDeviceCapabilities</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapDeviceCapabilities.html">PAirpcapDeviceCapabilities</a> *PCapabilities)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the capabilties of a device.  <a href="#gaece6915d2a521e566da9234eb74c0543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga63d4c48a95851444eb7284fc2a079127">AirpcapSetDeviceMacFlags</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT AirpcapMacFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the device's monitor mode and acknowledgment settings.  <a href="#ga63d4c48a95851444eb7284fc2a079127"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga89f8399c41ab04a4b6707a012105b8b7">AirpcapGetDeviceMacFlags</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PUINT PAirpcapMacFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the device's monitor mode and acknowledgement settings.  <a href="#ga89f8399c41ab04a4b6707a012105b8b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga1adedd10e4f67674277dcab81fe0fd14">AirpcapSetLinkType</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga141f7efbb58f0a6a71a77721624e70b1">AirpcapLinkType</a> NewLinkType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the link type of an adapter.  <a href="#ga1adedd10e4f67674277dcab81fe0fd14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga0b03cf3c1d8cac0baf85e14add7dcdd7">AirpcapGetLinkType</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga31cebe9e66582702cc475a62bfbcacd4">PAirpcapLinkType</a> PLinkType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the link type of the specified adapter.  <a href="#ga0b03cf3c1d8cac0baf85e14add7dcdd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga14cc811fb136709135e5fc7de26d2096">AirpcapSetFcsPresence</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, BOOL IsFcsPresent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the adapter on whether to include the MAC Frame Check Sequence in the captured packets.  <a href="#ga14cc811fb136709135e5fc7de26d2096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga8bece61b28b40593f5cd3f03422f3659">AirpcapGetFcsPresence</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PBOOL PIsFcsPresent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns TRUE if the specified adapter includes the MAC Frame Check Sequence in the captured packets.  <a href="#ga8bece61b28b40593f5cd3f03422f3659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae17c18f94e959905de419a7f065829fd">AirpcapSetFcsValidation</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> ValidationType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the adapter to accept or drop frames with an incorrect Frame Check sequence (FCS).  <a href="#gae17c18f94e959905de419a7f065829fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaa9a96792b5aa752b92cd4b14a87067e5">AirpcapGetFcsValidation</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga6fbd04165b7554386936352c08af8c79">PAirpcapValidationType</a> ValidationType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the specified adapter is configured to capture frames with incorrect an incorrect Frame Check Sequence (FCS).  <a href="#gaa9a96792b5aa752b92cd4b14a87067e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the list of decryption keys that AirPcap is going to use with the specified device.  <a href="#ga12a13dcb21b6afe5f9eb3497864a0eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga46c26b2b40b14eaba8b52d964d9d33b8">AirpcapGetDeviceKeys</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection, PUINT PKeysCollectionSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the list of decryption keys that are currently associated with the specified device.  <a href="#ga46c26b2b40b14eaba8b52d964d9d33b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the global list of decryption keys that AirPcap is going to use with all the devices.  <a href="#gab4bbee0e89e2ec706c680148f1163d4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae4c3345b7ff9a57e0379d55cd0ba575c">AirpcapGetDriverKeys</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a> KeysCollection, PUINT PKeysCollectionSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the global list of decryption keys that AirPcap is using with all the devices.  <a href="#gae4c3345b7ff9a57e0379d55cd0ba575c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga205739adab5b532ba07d342636a6506c">AirpcapSetDecryptionState</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a> Enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on or off the decryption of the incoming frames with the <b>device-specific</b> keys.  <a href="#ga205739adab5b532ba07d342636a6506c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga035b302cd3ad1fc6c95f71bf4534e538">AirpcapGetDecryptionState</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a> PEnable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>device-specific</b> keys.  <a href="#ga035b302cd3ad1fc6c95f71bf4534e538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga73f354cc8ec91e5715d30d2b2b343528">AirpcapSetDriverDecryptionState</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a> Enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on or off the decryption of the incoming frames with the <b>global</b> set of keys.  <a href="#ga73f354cc8ec91e5715d30d2b2b343528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga63fed593c1a47fa2b599519e9da1996f">AirpcapGetDriverDecryptionState</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a> PEnable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>global</b> set of keys.  <a href="#ga63fed593c1a47fa2b599519e9da1996f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT Channel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the radio channel of a device.  <a href="#ga4c4803da4b6f886e8f8bb5bd4ee89d03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga51ad4be210887ac0f6d70bc077fac780">AirpcapGetDeviceChannel</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PUINT PChannel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the radio channel of a device.  <a href="#ga51ad4be210887ac0f6d70bc077fac780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga0677e7ff539c4a0bb1154e2710bb371f">AirpcapSetDeviceChannelEx</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapChannelInfo.html">AirpcapChannelInfo</a> ChannelInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it sets the extension channel, if used.  <a href="#ga0677e7ff539c4a0bb1154e2710bb371f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga637e2f5d7f27ac7d3eaf75ed73d57910">AirpcapGetDeviceChannelEx</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> PChannelInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it gets the extension channel, if in use.  <a href="#ga637e2f5d7f27ac7d3eaf75ed73d57910"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> *ppChannelInfo, PUINT pNumChannelInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the list of supported channels for a given device. In case of a 802.11n capable device, information related to supported extension channels is also reported.  <a href="#ga9b94f343249d70d598e4b0db5c6561c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga4f8f1697634241f447f934de4d6cf065">AirpcapConvertFrequencyToChannel</a> (UINT Frequency, PUINT PChannel, <a class="el" href="group__airpcapdefs.html#ga171555564bf81b445c2880aaeefe8518">PAirpcapChannelBand</a> PBand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a given frequency to the corresponding channel.  <a href="#ga4f8f1697634241f447f934de4d6cf065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaab99902bf7bfc60b6bc47f92785298d5">AirpcapConvertChannelToFrequency</a> (UINT Channel, PUINT PFrequency)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a given channel to the corresponding frequency.  <a href="#gaab99902bf7bfc60b6bc47f92785298d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gae09c4d22f8bc55b4c3410e55b6d26395">AirpcapSetKernelBuffer</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT BufferSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the kernel packet buffer for this adapter.  <a href="#gae09c4d22f8bc55b4c3410e55b6d26395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga79d33b20e36a978e7fce0592af76571e">AirpcapGetKernelBufferSize</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PUINT PSizeBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the kernel packet buffer for this adapter.  <a href="#ga79d33b20e36a978e7fce0592af76571e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaf54106e440b1ca6c99cfaaaca57001fa">AirpcapSetTxPower</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT Power)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the power of the frames are transmitted by adapter.  <a href="#gaf54106e440b1ca6c99cfaaaca57001fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaea45264c8379fbda47668aa8f0e99ebe">AirpcapGetTxPower</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PUINT PPower)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current transmit power level of the adapter.  <a href="#gaea45264c8379fbda47668aa8f0e99ebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041">AirpcapStoreCurConfigAsAdapterDefault</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the configuration of the specified adapter in the registry, so that it becomes the default for this adapter.  <a href="#ga591ddeab1e4c8883e18d127724d1d041"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaae7f10fcd12b5263dc4af0ec83db03cf">AirpcapSetFilter</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PVOID Instructions, UINT Len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the BPF kernel filter for an adapter.  <a href="#gaae7f10fcd12b5263dc4af0ec83db03cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga6efbcac4adb18bc915ce902aced05134">AirpcapGetMacAddress</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a> PMacAddress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the MAC address of a device.  <a href="#ga6efbcac4adb18bc915ce902aced05134"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga36bc4d6aafa7b8e59da91761e50b5083">AirpcapSetMacAddress</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a> PMacAddress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the MAC address of a device.  <a href="#ga36bc4d6aafa7b8e59da91761e50b5083"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT MinToCopy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mintocopy parameter for an open adapter.  <a href="#ga276dc280fc36d07e40519a8606383f86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, HANDLE *PReadEvent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets an event that is signalled when packets are available in the kernel buffer (see <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>).  <a href="#ga3bb1ee017987102c70ea7da012e67559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10">AirpcapRead</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PBYTE Buffer, UINT BufSize, PUINT PReceievedBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills a user-provided buffer with zero or more packets that have been captured on the referenced adapter.  <a href="#ga28ea5971235f478c0bd3bd2ce1c63a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga70134a6b7dddf5b6227740474c0d1b95">AirpcapWrite</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PCHAR TxPacket, ULONG PacketLen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmits a packet.  <a href="#ga70134a6b7dddf5b6227740474c0d1b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaeb1de7c3fe8cb1d0c52147aac5eae356">AirpcapGetStats</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapStats.html">PAirpcapStats</a> PStats)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets per-adapter WinPcap-compatible capture statistics.  <a href="#gaeb1de7c3fe8cb1d0c52147aac5eae356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga15f6300567098e09294d3e0c93a7a4f4">AirpcapGetLedsNumber</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, PUINT NumberOfLeds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of LEDs the referenced adapter has available.  <a href="#ga15f6300567098e09294d3e0c93a7a4f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gaaf225a0632d8e077ef431ae994b8b16f">AirpcapTurnLedOn</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT LedNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns on one of the adapter's LEDs.  <a href="#gaaf225a0632d8e077ef431ae994b8b16f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#gafb0fe78ab2fa519d66aca8b22f6cad49">AirpcapTurnLedOff</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, UINT LedNumber)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns off one of the adapter's LEDs.  <a href="#gafb0fe78ab2fa519d66aca8b22f6cad49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__airpcapfuncs.html#ga16cde3ff1bbeea579bb3d85eac832963">AirpcapGetDeviceTimestamp</a> (<a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AdapterHandle, <a class="el" href="struct__AirpcapDeviceTimestamp.html">PAirpcapDeviceTimestamp</a> PTimestamp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current value of the device counter used to timestamp packets.  <a href="#ga16cde3ff1bbeea579bb3d85eac832963"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf2d048644aee82a6d60d14b694d8ea75"></a><!-- doxytag: member="airpcap.h::AirpcapGetVersion" ref="gaf2d048644aee82a6d60d14b694d8ea75" args="(PUINT VersionMajor, PUINT VersionMinor, PUINT VersionRev, PUINT VersionBuild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AirpcapGetVersion </td>
          <td>(</td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>VersionMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>VersionMinor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>VersionRev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>VersionBuild</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string with the API version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>VersionMajor</em>&nbsp;</td><td>Pointer to a variable that will be filled with the major version number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionMinor</em>&nbsp;</td><td>Pointer to a variable that will be filled with the minor version number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionRev</em>&nbsp;</td><td>Pointer to a variable that will be filled with the revision number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionBuild</em>&nbsp;</td><td>Pointer to a variable that will be filled with the build number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa659ca1646d89a1b5e79d2496b7dedce"></a><!-- doxytag: member="airpcap.h::AirpcapGetLastError" ref="gaa659ca1646d89a1b5e79d2496b7dedce" args="(PAirpcapHandle AdapterHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCHAR AirpcapGetLastError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the last error related to the specified handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to an open adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string with the last error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2d7dad3d18925221a312b24372d604"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceList" ref="ga4f2d7dad3d18925221a312b24372d604" args="(PAirpcapDeviceDescription *PPAllDevs, PCHAR Ebuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a> *&nbsp;</td>
          <td class="paramname"> <em>PPAllDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&nbsp;</td>
          <td class="paramname"> <em>Ebuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the list of available devices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PPAllDevs</em>&nbsp;</td><td>Address to a caller allocated pointer. On success this pointer will receive the head of a list of available devices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ebuf</em>&nbsp;</td><td>String that will contain error information if FALSE is returned. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. FALSE is returned on failure, in which case Ebuf is filled in with an appropriate error message.</dd></dl>
<p>Here's a snippet of code that shows how to use <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Returns the list of available devices.">AirpcapGetDeviceList()</a>:</p>
<div class="fragment"><pre class="fragment">    CHAR Ebuf[<a class="code" href="group__airpcapdefs.html#gaefe7d8c60ddf650b04dd74211d39cf4d" title="Size of the error buffer, in bytes.">AIRPCAP_ERRBUF_SIZE</a>];
    <a class="code" href="struct__AirpcapDeviceDescription.html" title="Entry in the list returned by AirpcapGetDeviceList().">AirpcapDeviceDescription</a> *Desc, *tDesc;

    <span class="keywordflow">if</span>(<a class="code" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Returns the list of available devices.">AirpcapGetDeviceList</a>(&amp;Desc, Ebuf) == -1)
    {
        printf(<span class="stringliteral">&quot;Unable to get the list of devices: %s\n&quot;</span>, Ebuf);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="keywordflow">for</span>(tDesc = Desc; tDesc; tDesc = tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#a8f0cb0cd405251c40de2ea36a8091397" title="Next element in the list.">next</a>)
    {
        printf(<span class="stringliteral">&quot;%u) %s (%s)\n&quot;</span>,
        ++i,
        tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#a193450584a7b39149f6e516dbb55f30a" title="Device name.">Name</a>,
        tDesc-&gt;<a class="code" href="struct__AirpcapDeviceDescription.html#ac18beae9bacc3550127fd2d4d47cd2de" title="Device description.">Description</a>);
    }

    <a class="code" href="group__airpcapfuncs.html#ga2ee2864654ca3fbd1f5c3a3e72efa992" title="Frees a list of devices returned by AirpcapGetDeviceList().">AirpcapFreeDeviceList</a>(Desc);
</pre></div> 
</div>
</div>
<a class="anchor" id="ga2ee2864654ca3fbd1f5c3a3e72efa992"></a><!-- doxytag: member="airpcap.h::AirpcapFreeDeviceList" ref="ga2ee2864654ca3fbd1f5c3a3e72efa992" args="(PAirpcapDeviceDescription PAllDevs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID AirpcapFreeDeviceList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceDescription.html">PAirpcapDeviceDescription</a>&nbsp;</td>
          <td class="paramname"> <em>PAllDevs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a list of devices returned by <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604" title="Returns the list of available devices.">AirpcapGetDeviceList()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PAllDevs</em>&nbsp;</td><td>Head of the list of devices returned by <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga69a24296462970dd8915aae1039b2bb3"></a><!-- doxytag: member="airpcap.h::AirpcapOpen" ref="ga69a24296462970dd8915aae1039b2bb3" args="(PCHAR DeviceName, PCHAR Ebuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a> AirpcapOpen </td>
          <td>(</td>
          <td class="paramtype">PCHAR&nbsp;</td>
          <td class="paramname"> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&nbsp;</td>
          <td class="paramname"> <em>Ebuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens an adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceName</em>&nbsp;</td><td>Name of the device to open. Use <a class="el" href="group__airpcapfuncs.html#ga4f2d7dad3d18925221a312b24372d604">AirpcapGetDeviceList()</a> to get the list of devices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ebuf</em>&nbsp;</td><td>String that will contain error information in case of failure. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PAirpcapHandle handle on success. NULL is returned on failure, in which case Ebuf is filled in with an appropriate error message. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75106eb2f2ce0a528b37bbc5b90f63af"></a><!-- doxytag: member="airpcap.h::AirpcapClose" ref="ga75106eb2f2ce0a528b37bbc5b90f63af" args="(PAirpcapHandle AdapterHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID AirpcapClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes an adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaece6915d2a521e566da9234eb74c0543"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceCapabilities" ref="gaece6915d2a521e566da9234eb74c0543" args="(PAirpcapHandle AdapterHandle, PAirpcapDeviceCapabilities *PCapabilities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceCapabilities.html">PAirpcapDeviceCapabilities</a> *&nbsp;</td>
          <td class="paramname"> <em>PCapabilities</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the capabilties of a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PCapabilities</em>&nbsp;</td><td>Pointer to a library-allocated <a class="el" href="group__airpcapdefs.html#ga32f2d91bd95548cb059c5083405c571f">AirpcapDeviceCapabilities</a> structure that contains the capabilities of the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The PCapabilities structure returned by <a class="el" href="group__airpcapfuncs.html#gaece6915d2a521e566da9234eb74c0543">AirpcapGetDeviceCapabilities()</a> must be considered invalid after the adapter has been closed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63d4c48a95851444eb7284fc2a079127"></a><!-- doxytag: member="airpcap.h::AirpcapSetDeviceMacFlags" ref="ga63d4c48a95851444eb7284fc2a079127" args="(PAirpcapHandle AdapterHandle, UINT AirpcapMacFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceMacFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>AirpcapMacFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the device's monitor mode and acknowledgment settings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AirpcapMacFlags</em>&nbsp;</td><td>Flags word, that contains a bitwise-OR combination of the following flags: <a class="el" href="group__airpcapdefs.html#ga2fef538a62660aec534d4a3b7a47bda6">AIRPCAP_MF_MONITOR_MODE_ON</a> and <a class="el" href="group__airpcapdefs.html#gaf4c32aaa6ca06ecc23cda7f12189f8e1">AIRPCAP_MF_ACK_FRAMES_ON</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>When an adapter is plugged into the system, it's always configured with monitor mode ON and acknowledgment settings OFF. These values are not stored persistently, so if you want to turn monitor mode off, you will need to do it every time you attach the adapter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>currently, the AirPcap adapter supports frames acknowleging when the adapter is NOT in monitor mode. This means that the combinations in which the two flags have the same value will cause <a class="el" href="group__airpcapfuncs.html#ga63d4c48a95851444eb7284fc2a079127" title="Sets the device&#39;s monitor mode and acknowledgment settings.">AirpcapSetDeviceMacFlags()</a> to fail. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89f8399c41ab04a4b6707a012105b8b7"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceMacFlags" ref="ga89f8399c41ab04a4b6707a012105b8b7" args="(PAirpcapHandle AdapterHandle, PUINT PAirpcapMacFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceMacFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PAirpcapMacFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the device's monitor mode and acknowledgement settings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PAirpcapMacFlags</em>&nbsp;</td><td>User-provided flags word, that will be filled by the function with an OR combination of the following flags: <a class="el" href="group__airpcapdefs.html#ga2fef538a62660aec534d4a3b7a47bda6">AIRPCAP_MF_MONITOR_MODE_ON</a> and <a class="el" href="group__airpcapdefs.html#gaf4c32aaa6ca06ecc23cda7f12189f8e1">AIRPCAP_MF_ACK_FRAMES_ON</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>When an adapter is plugged into the system, it's always configured with monitor mode ON and acknowledgment settings OFF. These values are not stored persistently, so if you want to turn monitor mode off, you will need to do it every time you attach the adapter. </p>

</div>
</div>
<a class="anchor" id="ga1adedd10e4f67674277dcab81fe0fd14"></a><!-- doxytag: member="airpcap.h::AirpcapSetLinkType" ref="ga1adedd10e4f67674277dcab81fe0fd14" args="(PAirpcapHandle AdapterHandle, AirpcapLinkType NewLinkType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetLinkType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga141f7efbb58f0a6a71a77721624e70b1">AirpcapLinkType</a>&nbsp;</td>
          <td class="paramname"> <em>NewLinkType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the link type of an adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewLinkType</em>&nbsp;</td><td>the "link type", i.e. the format of the frames that will be received from the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>the "link type" determines how the driver will encode the packets captured from the network. Aircap supports two link types:</p>
<ul>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932caccca07b1bce56bf355be0d773dc0a777">AIRPCAP_LT_802_11</a>, to capture 802.11 frames (including control frames) without any power information. Look at the "Capture_no_radio" example application in the developer's pack for a reference on how to decode 802.11 frames with this link type.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a>, to capture 802.11 frames (including control frames) with a radiotap header that contains power and channel information. More information about the radiotap header can be found in the <a class="el" href="group__radiotap.html">Information About the Radiotap Header</a> section. Moreover, the "Capture_radio" example application in the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca185676c98d51f262ed0b21f0abc11753">AIRPCAP_LT_802_11_PLUS_PPI</a>, to capture 802.11 frames (including control frames) with a Per Packet Information (PPI) header that contains per-packet meta information like channel and power information. More details on the PPI header can be found in the PPI online documentation (TODO). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga0b03cf3c1d8cac0baf85e14add7dcdd7"></a><!-- doxytag: member="airpcap.h::AirpcapGetLinkType" ref="ga0b03cf3c1d8cac0baf85e14add7dcdd7" args="(PAirpcapHandle AdapterHandle, PAirpcapLinkType PLinkType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetLinkType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga31cebe9e66582702cc475a62bfbcacd4">PAirpcapLinkType</a>&nbsp;</td>
          <td class="paramname"> <em>PLinkType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the link type of the specified adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PLinkType</em>&nbsp;</td><td>Pointer to a caller allocated AirpcapLinkType variable that will contain the link type of the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>the "link type" determines how the driver will encode the packets captured from the network. Aircap supports two link types:</p>
<ul>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932caccca07b1bce56bf355be0d773dc0a777">AIRPCAP_LT_802_11</a>, to capture 802.11 frames (including control frames) without any power information. Look at the "Capture_no_radio" example application in the developer's pack for a reference on how to decode 802.11 frames with this link type.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a>, to capture 802.11 frames (including control frames) with a radiotap header that contains power and channel information. More information about the radiotap header can be found int the <a class="el" href="group__radiotap.html">Information About the Radiotap Header</a> section. Moreover, the "Capture_radio" example application in the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers.</li>
<li><a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca185676c98d51f262ed0b21f0abc11753">AIRPCAP_LT_802_11_PLUS_PPI</a>, to capture 802.11 frames (including control frames) with a Per Packet Information (PPI) header that contains per-packet meta information like channel and power information. More details on the PPI header can be found in the PPI online documentation (TODO). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga14cc811fb136709135e5fc7de26d2096"></a><!-- doxytag: member="airpcap.h::AirpcapSetFcsPresence" ref="ga14cc811fb136709135e5fc7de26d2096" args="(PAirpcapHandle AdapterHandle, BOOL IsFcsPresent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFcsPresence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOL&nbsp;</td>
          <td class="paramname"> <em>IsFcsPresent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the adapter on whether to include the MAC Frame Check Sequence in the captured packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsFcsPresent</em>&nbsp;</td><td>TRUE if the packets should include the FCS. FALSE otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>In the default configuration, the adapter includes the FCS in the captured packets. The MAC Frame Check Sequence is 4 bytes and is located at the end of the 802.11 packet, with <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932caccca07b1bce56bf355be0d773dc0a777">AIRPCAP_LT_802_11</a>, <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a> and <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca185676c98d51f262ed0b21f0abc11753">AIRPCAP_LT_802_11_PLUS_PPI</a> link types. When the FCS inclusion is turned on, and if the link type is <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a>, the radiotap header that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present when FCS inclusion is off. </p>

</div>
</div>
<a class="anchor" id="ga8bece61b28b40593f5cd3f03422f3659"></a><!-- doxytag: member="airpcap.h::AirpcapGetFcsPresence" ref="ga8bece61b28b40593f5cd3f03422f3659" args="(PAirpcapHandle AdapterHandle, PBOOL PIsFcsPresent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetFcsPresence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBOOL&nbsp;</td>
          <td class="paramname"> <em>PIsFcsPresent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns TRUE if the specified adapter includes the MAC Frame Check Sequence in the captured packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PIsFcsPresent</em>&nbsp;</td><td>User-provided variable that will be set to true if the adapter is including the FCS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>In the default configuration, the adapter includes the FCS in the captured packets. The MAC Frame Check Sequence is 4 bytes and is located at the end of the 802.11 packet, with <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932caccca07b1bce56bf355be0d773dc0a777">AIRPCAP_LT_802_11</a>, <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a> and <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca185676c98d51f262ed0b21f0abc11753">AIRPCAP_LT_802_11_PLUS_PPI</a> link types. When the FCS inclusion is turned on, and if the link type is <a class="el" href="group__airpcapdefs.html#gga53cead1a819eb40b65554298b840932ca8c943a33948170293e062a185dba443e">AIRPCAP_LT_802_11_PLUS_RADIO</a>, the radiotap header that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present when FCS inclusion is off. </p>

</div>
</div>
<a class="anchor" id="gae17c18f94e959905de419a7f065829fd"></a><!-- doxytag: member="airpcap.h::AirpcapSetFcsValidation" ref="gae17c18f94e959905de419a7f065829fd" args="(PAirpcapHandle AdapterHandle, AirpcapValidationType ValidationType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFcsValidation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a>&nbsp;</td>
          <td class="paramname"> <em>ValidationType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the adapter to accept or drop frames with an incorrect Frame Check sequence (FCS). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ValidationType</em>&nbsp;</td><td>The type of validation the driver will perform. See the documentation of <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured in <a class="el" href="group__airpcapdefs.html#gga055511accfcb2816fce9782d9b57ad50a4c6ecd77d205c51cf150189e5358ec95">AIRPCAP_VT_ACCEPT_EVERYTHING</a> mode. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9a96792b5aa752b92cd4b14a87067e5"></a><!-- doxytag: member="airpcap.h::AirpcapGetFcsValidation" ref="gaa9a96792b5aa752b92cd4b14a87067e5" args="(PAirpcapHandle AdapterHandle, PAirpcapValidationType ValidationType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetFcsValidation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga6fbd04165b7554386936352c08af8c79">PAirpcapValidationType</a>&nbsp;</td>
          <td class="paramname"> <em>ValidationType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the specified adapter is configured to capture frames with incorrect an incorrect Frame Check Sequence (FCS). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ValidationType</em>&nbsp;</td><td>Pointer to a user supplied variable that will contain the type of validation the driver will perform. See the documentation of <a class="el" href="group__airpcapdefs.html#ga9a5d9c63fb74f8adf053b2851f1e3aac">AirpcapValidationType</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is succesful. FALSE otherwise.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured in <a class="el" href="group__airpcapdefs.html#gga055511accfcb2816fce9782d9b57ad50a4c6ecd77d205c51cf150189e5358ec95">AIRPCAP_VT_ACCEPT_EVERYTHING</a> mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12a13dcb21b6afe5f9eb3497864a0eb1"></a><!-- doxytag: member="airpcap.h::AirpcapSetDeviceKeys" ref="ga12a13dcb21b6afe5f9eb3497864a0eb1" args="(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&nbsp;</td>
          <td class="paramname"> <em>KeysCollection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the list of decryption keys that AirPcap is going to use with the specified device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle an open adapter instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeysCollection</em>&nbsp;</td><td>Pointer to a <a class="el" href="group__airpcapdefs.html#ga8d08c35bcb4e4a455c259c439fc9b98a">PAirpcapKeysCollection</a> structure that contains the keys to be set in the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>AirPcap is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>This function allows to set the <b>device-specific</b> set of keys. These keys will be used by the specified device only, and will not be used by other airpcap devices besides the specified one.</p>
<p>At this time, the only supported decryption method is WEP.</p>
<p>The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When you change the set of keys from an open capture instance, the change will be immediately reflected on all the other capture instances on the same device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46c26b2b40b14eaba8b52d964d9d33b8"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceKeys" ref="ga46c26b2b40b14eaba8b52d964d9d33b8" args="(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection, PUINT PKeysCollectionSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&nbsp;</td>
          <td class="paramname"> <em>KeysCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PKeysCollectionSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the list of decryption keys that are currently associated with the specified device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to an open adapter instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeysCollection</em>&nbsp;</td><td>User-allocated PAirpcapKeysCollection structure that will be filled with the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PKeysCollectionSize</em>&nbsp;</td><td><ul>
<li><b>IN:</b> pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes.</li>
<li><b>OUT:</b> amount of data moved by AirPcap in the buffer pointed by KeysBuffer, in bytes. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the needed KeysCollection length, in bytes. If the device doesn't have any decryption key configured, the return value is TRUE, and KeysCollectionSize will be zero.</dd></dl>
<p>This function returns the <b>device-specific</b> set of keys. These keys are used by the specified device only, and not by other airpcap devices besides the specified one.</p>
<p>AirPcap is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application. AirPcap supports, for every device, multiple keys at the same time.</p>
<p>The configured decryption keys are device-specific, therefore <a class="el" href="group__airpcapfuncs.html#ga46c26b2b40b14eaba8b52d964d9d33b8" title="Returns the list of decryption keys that are currently associated with the specified...">AirpcapGetDeviceKeys()</a> will return a different set of keys when called on different devices.</p>
<p>At this time, the only supported decryption method is WEP. </p>

</div>
</div>
<a class="anchor" id="gab4bbee0e89e2ec706c680148f1163d4d"></a><!-- doxytag: member="airpcap.h::AirpcapSetDriverKeys" ref="gab4bbee0e89e2ec706c680148f1163d4d" args="(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDriverKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&nbsp;</td>
          <td class="paramname"> <em>KeysCollection</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the global list of decryption keys that AirPcap is going to use with all the devices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle an open adapter instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeysCollection</em>&nbsp;</td><td>Pointer to a <a class="el" href="group__airpcapdefs.html#ga8d08c35bcb4e4a455c259c439fc9b98a">PAirpcapKeysCollection</a> structure that contains the keys to be set globally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>This function allows to set the <b>global</b> set of keys. These keys will be used by all the devices plugged in the machine.</p>
<p>At this time, the only supported decryption method is WEP.</p>
<p>The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When you change the set of keys from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4c3345b7ff9a57e0379d55cd0ba575c"></a><!-- doxytag: member="airpcap.h::AirpcapGetDriverKeys" ref="gae4c3345b7ff9a57e0379d55cd0ba575c" args="(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection, PUINT PKeysCollectionSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDriverKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapKeysCollection.html">PAirpcapKeysCollection</a>&nbsp;</td>
          <td class="paramname"> <em>KeysCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PKeysCollectionSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the global list of decryption keys that AirPcap is using with all the devices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to an open adapter instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>KeysCollection</em>&nbsp;</td><td>User-allocated PAirpcapKeysCollection structure that will be filled with the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PKeysCollectionSize</em>&nbsp;</td><td><ul>
<li><b>IN:</b> pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes.</li>
<li><b>OUT:</b> amount of data moved by AirPcap in the buffer pointed by KeysBuffer, in bytes. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the needed KeysCollection length, in bytes. If no global decryption keys are configured, the return value is TRUE, and KeysCollectionSize will be zero.</dd></dl>
<p>This function returns the <b>global</b> set of keys. These keys will be used by all the devices plugged in the machine.</p>
<p>The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames to the application.</p>
<p>At this time, the only supported decryption method is WEP. </p>

</div>
</div>
<a class="anchor" id="ga205739adab5b532ba07d342636a6506c"></a><!-- doxytag: member="airpcap.h::AirpcapSetDecryptionState" ref="ga205739adab5b532ba07d342636a6506c" args="(PAirpcapHandle AdapterHandle, AirpcapDecryptionState Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDecryptionState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a>&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns on or off the decryption of the incoming frames with the <b>device-specific</b> keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>Either <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a> or <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a5cdd06a36410cf0163d5621adcf39512">AIRPCAP_DECRYPTION_OFF</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The device-specific decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> function. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga035b302cd3ad1fc6c95f71bf4534e538"></a><!-- doxytag: member="airpcap.h::AirpcapGetDecryptionState" ref="ga035b302cd3ad1fc6c95f71bf4534e538" args="(PAirpcapHandle AdapterHandle, PAirpcapDecryptionState PEnable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDecryptionState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a>&nbsp;</td>
          <td class="paramname"> <em>PEnable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>device-specific</b> keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PEnable</em>&nbsp;</td><td>Pointer to a user supplied variable that will contain the decryption configuration. See <a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is succesful. FALSE otherwise.</dd></dl>
<p>The device-specific decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> function. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73f354cc8ec91e5715d30d2b2b343528"></a><!-- doxytag: member="airpcap.h::AirpcapSetDriverDecryptionState" ref="ga73f354cc8ec91e5715d30d2b2b343528" args="(PAirpcapHandle AdapterHandle, AirpcapDecryptionState Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDriverDecryptionState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga1524eaffea4a4ff173bf52c9da577fb8">AirpcapDecryptionState</a>&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns on or off the decryption of the incoming frames with the <b>global</b> set of keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>Either <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a> or <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a5cdd06a36410cf0163d5621adcf39512">AIRPCAP_DECRYPTION_OFF</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The global decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys()</a> function. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63fed593c1a47fa2b599519e9da1996f"></a><!-- doxytag: member="airpcap.h::AirpcapGetDriverDecryptionState" ref="ga63fed593c1a47fa2b599519e9da1996f" args="(PAirpcapHandle AdapterHandle, PAirpcapDecryptionState PEnable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDriverDecryptionState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a>&nbsp;</td>
          <td class="paramname"> <em>PEnable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>global</b> set of keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PEnable</em>&nbsp;</td><td>Pointer to a user supplied variable that will contain the decryption configuration. See <a class="el" href="group__airpcapdefs.html#ga9cb94813239afe5958358d6e86f926ca">PAirpcapDecryptionState</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the operation is successful. FALSE otherwise.</dd></dl>
<p>The global decryption keys can be configured with the <a class="el" href="group__airpcapfuncs.html#gab4bbee0e89e2ec706c680148f1163d4d">AirpcapSetDriverKeys()</a> function. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>By default, the driver is configured with <a class="el" href="group__airpcapdefs.html#gga8835457664df3e51e23d0d8f538d0c70a339aa5033f0054860e25ccf916bff5f1">AIRPCAP_DECRYPTION_ON</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c4803da4b6f886e8f8bb5bd4ee89d03"></a><!-- doxytag: member="airpcap.h::AirpcapSetDeviceChannel" ref="ga4c4803da4b6f886e8f8bb5bd4ee89d03" args="(PAirpcapHandle AdapterHandle, UINT Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the radio channel of a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>the new channel to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The list of available channels can be retrieved with <a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels()</a>. The default channel setting is 6.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ad4be210887ac0f6d70bc077fac780"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceChannel" ref="ga51ad4be210887ac0f6d70bc077fac780" args="(PAirpcapHandle AdapterHandle, PUINT PChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PChannel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the radio channel of a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PChannel</em>&nbsp;</td><td>Pointer to a user-supplied variable into which the function will copy the currently configured radio channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The list of available channels can be retrieved with <a class="el" href="group__airpcapfuncs.html#ga9b94f343249d70d598e4b0db5c6561c1">AirpcapGetDeviceSupportedChannels()</a>. The default channel setting is 6.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0677e7ff539c4a0bb1154e2710bb371f"></a><!-- doxytag: member="airpcap.h::AirpcapSetDeviceChannelEx" ref="ga0677e7ff539c4a0bb1154e2710bb371f" args="(PAirpcapHandle AdapterHandle, AirpcapChannelInfo ChannelInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetDeviceChannelEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapChannelInfo.html">AirpcapChannelInfo</a>&nbsp;</td>
          <td class="paramname"> <em>ChannelInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it sets the extension channel, if used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChannelInfo</em>&nbsp;</td><td>The new channel information to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga637e2f5d7f27ac7d3eaf75ed73d57910"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceChannelEx" ref="ga637e2f5d7f27ac7d3eaf75ed73d57910" args="(PAirpcapHandle AdapterHandle, PAirpcapChannelInfo PChannelInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceChannelEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a>&nbsp;</td>
          <td class="paramname"> <em>PChannelInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it gets the extension channel, if in use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PChannelInfo</em>&nbsp;</td><td>Pointer to a user-supplied variable into which the function will copy the currently configured channel information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a device-related function: when you change the channel from an open capture instance, the change will be immediately reflected on all the other capture instances. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b94f343249d70d598e4b0db5c6561c1"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceSupportedChannels" ref="ga9b94f343249d70d598e4b0db5c6561c1" args="(PAirpcapHandle AdapterHandle, PAirpcapChannelInfo *ppChannelInfo, PUINT pNumChannelInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceSupportedChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapChannelInfo.html">PAirpcapChannelInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ppChannelInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>pNumChannelInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the list of supported channels for a given device. In case of a 802.11n capable device, information related to supported extension channels is also reported. </p>
<p>Every control channel is listed multiple times, one for each different supported extension channel. For example channel 6 (2437MHz) is usually listed three times:</p>
<ul>
<li><b>Frequency 2437 Extension +1</b>. Control channel is 6, extension channel is 10.</li>
<li><b>Frequency 2437 Extension 0</b>. Control channel is 6, no extension channel is used (20MHz channel and legacy mode).</li>
<li><b>Frequency 2437 Extension -1</b>. Control channel is 6, extension channel is 2. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppChannelInfo</em>&nbsp;</td><td>Pointer to a user-supplied variable that will point to an array of supported channel. Such list must not be freed by the caller </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNumChannelInfo</em>&nbsp;</td><td>Number of channels returned in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The supported channels are not listed in any specific order. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga4f8f1697634241f447f934de4d6cf065"></a><!-- doxytag: member="airpcap.h::AirpcapConvertFrequencyToChannel" ref="ga4f8f1697634241f447f934de4d6cf065" args="(UINT Frequency, PUINT PChannel, PAirpcapChannelBand PBand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapConvertFrequencyToChannel </td>
          <td>(</td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>Frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga171555564bf81b445c2880aaeefe8518">PAirpcapChannelBand</a>&nbsp;</td>
          <td class="paramname"> <em>PBand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a given frequency to the corresponding channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Frequency</em>&nbsp;</td><td>Frequency of the channel, in MHz. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PChannel</em>&nbsp;</td><td>Pointer to a user-supplied variable that will contain the channel number on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PBand</em>&nbsp;</td><td>Pointer to a user-supplied variable that will contain the band (a or b/g) of the given channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, i.e. the frequency corresponds to a valid a or b/g channel. </dd></dl>

</div>
</div>
<a class="anchor" id="gaab99902bf7bfc60b6bc47f92785298d5"></a><!-- doxytag: member="airpcap.h::AirpcapConvertChannelToFrequency" ref="gaab99902bf7bfc60b6bc47f92785298d5" args="(UINT Channel, PUINT PFrequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapConvertChannelToFrequency </td>
          <td>(</td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PFrequency</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a given channel to the corresponding frequency. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>Channel number to be converted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PFrequency</em>&nbsp;</td><td>Pointer to a user-supplied variable that will contain the channel frequency in MHz on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, i.e. the given channel number exists.</dd></dl>
<p>Because of the overlap of channels with respect to 1-14BG and 1-14A, this function will give precidence to BG. Thus, the channels are returned as follows:</p>
<ul>
<li><b>Channel 0:</b> 5000MHz</li>
<li><b>Channels 1-14:</b> 2412MHz - 2484MHz</li>
<li><b>Channels 15-239:</b> 5005MHz - 6195MHz</li>
<li><b>Channels 240-255:</b> 4920MHz - 4995MHz </li>
</ul>

</div>
</div>
<a class="anchor" id="gae09c4d22f8bc55b4c3410e55b6d26395"></a><!-- doxytag: member="airpcap.h::AirpcapSetKernelBuffer" ref="gae09c4d22f8bc55b4c3410e55b6d26395" args="(PAirpcapHandle AdapterHandle, UINT BufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetKernelBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>BufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the size of the kernel packet buffer for this adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferSize</em>&nbsp;</td><td>New size, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte. This function can be used to change the size of this buffer, and can be called at any time. A bigger kernel buffer size decreases the risk of dropping packets during network bursts or when the application is busy, at the cost of higher kernel memory usage.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't use this function unless you know what you are doing. Due to caching issues and bigger non-paged memory consumption, bigger buffer sizes can decrease the capture performace instead of improving it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79d33b20e36a978e7fce0592af76571e"></a><!-- doxytag: member="airpcap.h::AirpcapGetKernelBufferSize" ref="ga79d33b20e36a978e7fce0592af76571e" args="(PAirpcapHandle AdapterHandle, PUINT PSizeBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetKernelBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PSizeBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the kernel packet buffer for this adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PSizeBytes</em>&nbsp;</td><td>User-allocated variable that will be filled with the size of the kernel buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte. This function can be used to get the size of this buffer. </p>

</div>
</div>
<a class="anchor" id="gaf54106e440b1ca6c99cfaaaca57001fa"></a><!-- doxytag: member="airpcap.h::AirpcapSetTxPower" ref="gaf54106e440b1ca6c99cfaaaca57001fa" args="(PAirpcapHandle AdapterHandle, UINT Power)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetTxPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>Power</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the power of the frames are transmitted by adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Power</em>&nbsp;</td><td>The transmit power. Setting a zero power makes the adapter select the highest possible power for the current channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. False on failure or if the adapter doesn't support setting the transmit power.</dd></dl>
<p>The transmit power value is monotonically increasing with higher power levels. 1 is the minimum allowed transmit power.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The maximum transmit power on each channel is limited by FCC regulations. Therefore, the maximum transmit power changes from channel to channel. When the channel is changed with <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> or <a class="el" href="group__airpcapfuncs.html#ga0677e7ff539c4a0bb1154e2710bb371f">AirpcapSetDeviceChannelEx()</a> the power is set to the maximum allowd value for that channel. You can read this value with <a class="el" href="group__airpcapfuncs.html#gaea45264c8379fbda47668aa8f0e99ebe">AirpcapGetTxPower()</a>. Not all the AirPcap adapters support setting the transmit power; you can use <a class="el" href="group__airpcapfuncs.html#gaece6915d2a521e566da9234eb74c0543">AirpcapGetDeviceCapabilities()</a> to find if the current adapter supports this feature. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea45264c8379fbda47668aa8f0e99ebe"></a><!-- doxytag: member="airpcap.h::AirpcapGetTxPower" ref="gaea45264c8379fbda47668aa8f0e99ebe" args="(PAirpcapHandle AdapterHandle, PUINT PPower)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetTxPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PPower</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current transmit power level of the adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PPower</em>&nbsp;</td><td>User-allocated variable that will be filled with the size of the transmit power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. False on failure or if the adapter doesn't support getting the transmit power.</dd></dl>
<p>The transmit power value is monotonically increasing with higher power levels. 0 is the minimum allowed power.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The maximum transmit power on each channel is limited by FCC regulations. Therefore, the maximum transmit power changes from channel to channel. When the channel is changed with <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> or <a class="el" href="group__airpcapfuncs.html#ga0677e7ff539c4a0bb1154e2710bb371f">AirpcapSetDeviceChannelEx()</a> the power is set to the maximum allowd value for that channel. Not all the AirPcap adapters support setting the transmit power; you can use <a class="el" href="group__airpcapfuncs.html#gaece6915d2a521e566da9234eb74c0543">AirpcapGetDeviceCapabilities()</a> to find if the current adapter supports this feature. </dd></dl>

</div>
</div>
<a class="anchor" id="ga591ddeab1e4c8883e18d127724d1d041"></a><!-- doxytag: member="airpcap.h::AirpcapStoreCurConfigAsAdapterDefault" ref="ga591ddeab1e4c8883e18d127724d1d041" args="(PAirpcapHandle AdapterHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapStoreCurConfigAsAdapterDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves the configuration of the specified adapter in the registry, so that it becomes the default for this adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. FALSE on failure.</dd></dl>
<p>Almost all the AirPcap calls that modify the configuration (<a class="el" href="group__airpcapfuncs.html#ga1adedd10e4f67674277dcab81fe0fd14">AirpcapSetLinkType()</a>, <a class="el" href="group__airpcapfuncs.html#ga14cc811fb136709135e5fc7de26d2096">AirpcapSetFcsPresence()</a>, <a class="el" href="group__airpcapfuncs.html#gae17c18f94e959905de419a7f065829fd">AirpcapSetFcsValidation()</a>, <a class="el" href="group__airpcapfuncs.html#gae09c4d22f8bc55b4c3410e55b6d26395">AirpcapSetKernelBuffer()</a>, <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>) affect only the referenced AirPcap open instance. This means that if you do another <a class="el" href="group__airpcapfuncs.html#ga69a24296462970dd8915aae1039b2bb3">AirpcapOpen()</a> on the same adapter, the configuration changes will not be remembered, and the new adapter handle will have default configuration settings.</p>
<p>Exceptions to this rule are the <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> and <a class="el" href="group__airpcapfuncs.html#ga12a13dcb21b6afe5f9eb3497864a0eb1">AirpcapSetDeviceKeys()</a> functions: a channel change is reflected on all the open instances, and remembered until the next call to <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a>, until the adapter is unplugged, or until the machine is powered off. Same thing for the configuration of the WEP keys.</p>
<p><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes...">AirpcapStoreCurConfigAsAdapterDefault()</a> stores the configuration of the give open instance as the default for the adapter: all the instances opened in the future will have the same configuration that this adapter currently has. The configuration is stored in the registry, therefore it is remembered even when the adapter is unplugged or the machine is turned off. However, an adapter doesn't bring its configuration with it from machine to machine.</p>
<p>the configuration information saved in the registry includes the following parameters:</p>
<ul>
<li>channel</li>
<li>kernel buffer size</li>
<li>mintocopy</li>
<li>link type</li>
<li>CRC presence</li>
<li>Encryption keys</li>
<li>Encryption Enabled/Disabled state</li>
</ul>
<p>The configuration is device-specific. This means that changing the configuration of a device doesn't modify the one of the other devices that are currently used or that will be used in the future.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes...">AirpcapStoreCurConfigAsAdapterDefault()</a> must have exclusive access to the adapter -- it will fail if more than one AirPcap handle is opened at the same time for this device. <a class="el" href="group__airpcapfuncs.html#ga591ddeab1e4c8883e18d127724d1d041" title="Saves the configuration of the specified adapter in the registry, so that it becomes...">AirpcapStoreCurConfigAsAdapterDefault()</a> needs administrator privileges. It will fail if the calling user is not a local machine administrator. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae7f10fcd12b5263dc4af0ec83db03cf"></a><!-- doxytag: member="airpcap.h::AirpcapSetFilter" ref="gaae7f10fcd12b5263dc4af0ec83db03cf" args="(PAirpcapHandle AdapterHandle, PVOID Instructions, UINT Len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID&nbsp;</td>
          <td class="paramname"> <em>Instructions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>Len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the BPF kernel filter for an adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Instructions</em>&nbsp;</td><td>pointer to the first BPF instruction in the array. Corresponds to the bf_insns in a bpf_program structure (see the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Len</em>&nbsp;</td><td>Number of instructions in the array pointed by the previous field. Corresponds to the bf_len in a a bpf_program structure (see the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The AirPcap driver is able to perform kernel-level filtering using the standard BPF pseudo-machine format. You can read the WinPcap documentation at <a href="http://www.winpcap.org/devel.htm">http://www.winpcap.org/devel.htm</a> for more details on the BPF filtering mechaism.</p>
<p>A filter can be automatically created by using the pcap_compile() function of the WinPcap API. This function converts a human readable text expression with the tcpdump/libpcap syntax into a BPF program. If your program doesn't link wpcap, but you need to generate the code for a particular filter, you can run WinDump with the -d or -dd or -ddd flags to obtain the pseudocode. </p>

</div>
</div>
<a class="anchor" id="ga6efbcac4adb18bc915ce902aced05134"></a><!-- doxytag: member="airpcap.h::AirpcapGetMacAddress" ref="ga6efbcac4adb18bc915ce902aced05134" args="(PAirpcapHandle AdapterHandle, PAirpcapMacAddress PMacAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a>&nbsp;</td>
          <td class="paramname"> <em>PMacAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the MAC address of a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PMacAddress</em>&nbsp;</td><td>Pointer to a user allocated <a class="el" href="group__airpcapdefs.html#ga943940247c66ad034726b0aee22cfa8d">AirpcapMacAddress</a> structure that will receive the MAC address on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36bc4d6aafa7b8e59da91761e50b5083"></a><!-- doxytag: member="airpcap.h::AirpcapSetMacAddress" ref="ga36bc4d6aafa7b8e59da91761e50b5083" args="(PAirpcapHandle AdapterHandle, PAirpcapMacAddress PMacAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetMacAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapMacAddress.html">PAirpcapMacAddress</a>&nbsp;</td>
          <td class="paramname"> <em>PMacAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the MAC address of a device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PMacAddress</em>&nbsp;</td><td>Pointer to a user-initialized structure containing the MAC address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. FALSE on failure, or if the adapter doesn't support changing the address.</dd></dl>
<p>Using this function, the programmer can change the MAC address of the device. This is useful when disabling monitor mode with <a class="el" href="group__airpcapfuncs.html#ga63d4c48a95851444eb7284fc2a079127">AirpcapSetDeviceMacFlags()</a>, because the device will acknowledge the data frames sent to its MAC address.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The address change is temporary: when the device is unplugged or when the host PC is turned off, the address is reset to the original value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga276dc280fc36d07e40519a8606383f86"></a><!-- doxytag: member="airpcap.h::AirpcapSetMinToCopy" ref="ga276dc280fc36d07e40519a8606383f86" args="(PAirpcapHandle AdapterHandle, UINT MinToCopy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapSetMinToCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>MinToCopy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the mintocopy parameter for an open adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MinToCopy</em>&nbsp;</td><td>is the mintocopy size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>When the number of bytes in the kernel buffer changes from less than mintocopy bytes to greater than or equal to mintocopy bytes, the read event is signalled (see <a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent()</a>). A high value for mintocopy results in poor responsiveness since the driver may signal the application "long" after the arrival of the packet. And a high value results in low CPU loading by minimizing the number of user/kernel context switches. A low MinToCopy results in good responsiveness since the driver will signal the application close to the arrival time of the packet. This has higher CPU loading over the first approach. </p>

</div>
</div>
<a class="anchor" id="ga3bb1ee017987102c70ea7da012e67559"></a><!-- doxytag: member="airpcap.h::AirpcapGetReadEvent" ref="ga3bb1ee017987102c70ea7da012e67559" args="(PAirpcapHandle AdapterHandle, HANDLE *PReadEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetReadEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE *&nbsp;</td>
          <td class="paramname"> <em>PReadEvent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an event that is signalled when packets are available in the kernel buffer (see <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PReadEvent</em>&nbsp;</td><td>Pointer to a user-supplied handle in which the read event will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The event is signalled when at least mintocopy bytes are present in the kernel buffer (see <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>). This event can be used by WaitForSingleObject() and WaitForMultipleObjects() to create blocking behavior when reading packets from one or more adapters (see <a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10">AirpcapRead()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga28ea5971235f478c0bd3bd2ce1c63a10"></a><!-- doxytag: member="airpcap.h::AirpcapRead" ref="ga28ea5971235f478c0bd3bd2ce1c63a10" args="(PAirpcapHandle AdapterHandle, PBYTE Buffer, UINT BufSize, PUINT PReceievedBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PBYTE&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>BufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>PReceievedBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a user-provided buffer with zero or more packets that have been captured on the referenced adapter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>pointer to the buffer that will be filled with captured packets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufSize</em>&nbsp;</td><td>size of the input buffer that will contain the packets, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PReceievedBytes</em>&nbsp;</td><td>Pointer to a user supplied variable that will receive the number of bytes copied by AirpcapRead. Can be smaller than BufSize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>802.11 frames are returned by the driver in buffers. Every 802.11 frame in the buffer is preceded by a <a class="el" href="group__airpcapdefs.html#ga595a576fc245c805a444cfd20d65a2af">AirpcapBpfHeader</a> structure. The suggested way to use an AirPcap adapter is through the pcap API exported by wpcap.dll. If this is not possible, the Capture_radio and Capture_no_radio examples in the AirPcap developer's pack show how to properly decode the packets in the read buffer returned by <a class="el" href="group__airpcapfuncs.html#ga28ea5971235f478c0bd3bd2ce1c63a10" title="Fills a user-provided buffer with zero or more packets that have been captured on...">AirpcapRead()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is NOT blocking. Blocking behavior can be obtained using the event returned by <a class="el" href="group__airpcapfuncs.html#ga3bb1ee017987102c70ea7da012e67559">AirpcapGetReadEvent()</a>. See also <a class="el" href="group__airpcapfuncs.html#ga276dc280fc36d07e40519a8606383f86">AirpcapSetMinToCopy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga70134a6b7dddf5b6227740474c0d1b95"></a><!-- doxytag: member="airpcap.h::AirpcapWrite" ref="ga70134a6b7dddf5b6227740474c0d1b95" args="(PAirpcapHandle AdapterHandle, PCHAR TxPacket, ULONG PacketLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PCHAR&nbsp;</td>
          <td class="paramname"> <em>TxPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&nbsp;</td>
          <td class="paramname"> <em>PacketLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmits a packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxPacket</em>&nbsp;</td><td>Pointer to a buffer that contains the packet to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PacketLen</em>&nbsp;</td><td>Length of the buffer pointed by the TxPacket argument, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success.</dd></dl>
<p>The packet will be transmitted on the channel the device is currently set. To change the device adapter, use the <a class="el" href="group__airpcapfuncs.html#ga4c4803da4b6f886e8f8bb5bd4ee89d03">AirpcapSetDeviceChannel()</a> function.</p>
<p>If the link type of the adapter is AIRPCAP_LT_802_11, the buffer pointed by TxPacket should contain just the 802.11 packet, without additional information. The packet will be transmitted at 1Mbps.</p>
<p>If the link type of the adapter is AIRPCAP_LT_802_11_PLUS_RADIO, the buffer pointed by TxPacket should contain a radiotap header followed by the 802.11 packet. AirpcapWrite will use the rate information in the radiotap header when transmitting the packet.</p>
<p>If the link type of the adapter is AIRPCAP_LT_802_11_PLUS_PPI, the buffer pointed by TxPacket should contain a PPI header followed by the 802.11 packet. AirpcapWrite will use the rate information in the PPI header when transmitting the packet. If the packet should be transmitted at a 802.11n rate, the packet must include a PPI 802.11n MAC+PHY Extension header, containing the rate expressed in terms of MCS, short/long guard interval (SGI/LGI) and 20MHz or 40MHz channel. When the MAC+PHY Extension header is present, the rate field in the PPI 802.11-Common header is ignored. By default on 802.11n-capable AirPcap adapters, packets are transmitted with no A-MPDU aggregation. A-MPDU aggregation is controlled by the adapter, but it's possible to give a hint to the hardware to aggregate some packets by setting the "Aggregate" and "More aggregates" flags in the PPI 802.11n MAC+PHY extension header. </p>

</div>
</div>
<a class="anchor" id="gaeb1de7c3fe8cb1d0c52147aac5eae356"></a><!-- doxytag: member="airpcap.h::AirpcapGetStats" ref="gaeb1de7c3fe8cb1d0c52147aac5eae356" args="(PAirpcapHandle AdapterHandle, PAirpcapStats PStats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapStats.html">PAirpcapStats</a>&nbsp;</td>
          <td class="paramname"> <em>PStats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets per-adapter WinPcap-compatible capture statistics. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PStats</em>&nbsp;</td><td>pointer to a user-allocated AirpcapStats structure that will be filled with statistical information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga15f6300567098e09294d3e0c93a7a4f4"></a><!-- doxytag: member="airpcap.h::AirpcapGetLedsNumber" ref="ga15f6300567098e09294d3e0c93a7a4f4" args="(PAirpcapHandle AdapterHandle, PUINT NumberOfLeds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetLedsNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PUINT&nbsp;</td>
          <td class="paramname"> <em>NumberOfLeds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of LEDs the referenced adapter has available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumberOfLeds</em>&nbsp;</td><td>Number of LEDs available on this adapter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf225a0632d8e077ef431ae994b8b16f"></a><!-- doxytag: member="airpcap.h::AirpcapTurnLedOn" ref="gaaf225a0632d8e077ef431ae994b8b16f" args="(PAirpcapHandle AdapterHandle, UINT LedNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapTurnLedOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>LedNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns on one of the adapter's LEDs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LedNumber</em>&nbsp;</td><td>zero-based identifier of the LED to turn on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb0fe78ab2fa519d66aca8b22f6cad49"></a><!-- doxytag: member="airpcap.h::AirpcapTurnLedOff" ref="gafb0fe78ab2fa519d66aca8b22f6cad49" args="(PAirpcapHandle AdapterHandle, UINT LedNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapTurnLedOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&nbsp;</td>
          <td class="paramname"> <em>LedNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns off one of the adapter's LEDs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LedNumber</em>&nbsp;</td><td>zero-based identifier of the LED to turn off. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16cde3ff1bbeea579bb3d85eac832963"></a><!-- doxytag: member="airpcap.h::AirpcapGetDeviceTimestamp" ref="ga16cde3ff1bbeea579bb3d85eac832963" args="(PAirpcapHandle AdapterHandle, PAirpcapDeviceTimestamp PTimestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL AirpcapGetDeviceTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__airpcapdefs.html#ga0f6bb3d5a44e7379f6519435d011bbc7">PAirpcapHandle</a>&nbsp;</td>
          <td class="paramname"> <em>AdapterHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__AirpcapDeviceTimestamp.html">PAirpcapDeviceTimestamp</a>&nbsp;</td>
          <td class="paramname"> <em>PTimestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current value of the device counter used to timestamp packets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdapterHandle</em>&nbsp;</td><td>Handle to the adapter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PTimestamp</em>&nbsp;</td><td>Pointer to a caller allocated 64bit integer that will receive the device timestamp, in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success. </dd></dl>

</div>
</div>
</div>

<hr>
<p align="right"><font size="2">
<img border="0" src="../pics/cace_small.jpg" align="absbottom"> AirPcap documentation. Copyright (c) 2006-2008 
CACE Technologies, Inc. All rights reserved.</font></p>

			</td>
		</tr>
	</table>

    </BODY>
  </HTML>
