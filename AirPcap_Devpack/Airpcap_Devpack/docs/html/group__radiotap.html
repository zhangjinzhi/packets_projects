<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AirPcap: Information About the Radiotap Header</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="airpcap.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>Information About the Radiotap Header</h1><table border="0" cellpadding="0" cellspacing="0">
</table>
<p><b>Acknowledgements</b></p>
<p>Most of this information is taken from the madwifi wiki: <a href="http://madwifi.org/wiki/">http://madwifi.org/wiki/</a></p>
<p><b>Background</b></p>
<p>The radiotap header format is a mechanism to supply additional information about frames from the driver to userspace applications based on WinPcap/libpcap. Designed initially for NetBSD systems by David Young, the radiotap header format is compact, flexible, and allows the driver to specify an arbitrary number of fields based on a bitmask presence field in the radiotap header.</p>
<p><b>Format Specification</b></p>
<p>The radiotap capture format starts with a radiotap header:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>ieee80211_radiotap_header 
{
        u_int8_t        it_version;     <span class="comment">/* set to 0 */</span>
        u_int8_t        it_pad;
        u_int16_t       it_len;         <span class="comment">/* entire length */</span>
        u_int32_t       it_present;     <span class="comment">/* fields present */</span>
};
</pre></div><p>The it_version field indicates which major version of the radiotap header is in use. Currently, this is always 0. Adding support for additional radiotap fields does not change the version number.</p>
<p>The it_pad field is currently unused, it simply aligns the fields onto natural word boundaries.</p>
<p>The it_len field indicates the entire length of the radiotap data, including the radiotap header. This is valuable for the developer so they can consistently locate the beginning of the 802.11 frame that follows the radiotap data, even if their parser doesn't understand all of the data fields specified.</p>
<p>The it_present field is a bitmask of the radiotap data fields that follows the radiotap header. The currently supported list of radiotap header fields can be found in ieee80211_radiotap.h. Briefly, they are identified as follows:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> ieee80211_radiotap_type {
        IEEE80211_RADIOTAP_TSFT = 0,
        IEEE80211_RADIOTAP_FLAGS = 1,
        IEEE80211_RADIOTAP_RATE = 2,
        IEEE80211_RADIOTAP_CHANNEL = 3,
        IEEE80211_RADIOTAP_FHSS = 4,
        IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
        IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
        IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
        IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
        IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
        IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
        IEEE80211_RADIOTAP_ANTENNA = 11,
        IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
        IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
        IEEE80211_RADIOTAP_FCS = 14,
        IEEE80211_RADIOTAP_EXT = 31,
};
</pre></div><p>Provided the IEEE80211_RADIOTAP_EXT bit is not set, the data for fields specified in the it_present bitmask immediately follow the radiotap header.</p>
<p>One of the advantages of radiotap is that new fields can be added to the end of the radiotap data without breaking existing parsers. If a parser identifies a bitmask value that is not recognized, it can skip to the end of the radiotap data by referencing the header it_len field.</p>
<p><b>Important Radiotap Characteristics</b></p>
<ul>
<li>Fields are in strict-order; The developer can specify any combination of fields, but the data must appear following the radiotap header in the order they are specified in the it_present bitmask (or more accurately, in the order they are specified in the ieee80211_radiotap_type enum).</li>
<li>Data is specified in little endian byte-order; All data fields including the it_version, it_len and it_present fields in the radiotap header are to be specified in little endian byte-order. Developers should use make use of the cpu_to_leNN and leNN_to_cpu macros to convert appropriately.</li>
<li>Field lengths are implicit; The radiotap header format does not specify field lengths, it is expected that the developer knows the corresponding length based on the data field name;</li>
<li>Variable-length fields are not supported; Since field lengths are implicit, variable-length fields are not supported in the radiotap header format.</li>
<li>Support for extended bitmasks; If bit 31 of the it_present field is set, an extended it_present bitmask is present. Developers should check for the presence of bit 31 in the it_present field to identify if a second 32-bit bitmask follows the radiotap header instead of assuming the beginning of the radiotap data immediately follows the radiotap header. Note that additional bitmask may be chained to the end of extended bitmasks as well by setting bit 31.</li>
<li>Natural alignment field requirement; The radiotap manual page requires that 16-bit, 32-bit and 64-bit fields be naturally aligned on even-byte boundaries. See the section Alignment in Radiotap below for more information.</li>
</ul>
<p><b>Alignment in Radiotap</b></p>
<p>The Radiotap Manual Page indicates that fields in the radiotap header aligned to natural boundaries:</p>
<p>Radiotap capture fields must be naturally aligned. That is, 16-, 32-, and 64-bit fields must begin on 16-, 32-, and 64-bit boundaries, respectively. In this way, drivers can avoid unaligned accesses to radiotap capture fields. radiotap-compliant drivers must insert padding before a capture field to ensure its natural alignment. radiotap-compliant packet dissectors, such as WinDump (<a href="http://www.winpcap.org/windump">http://www.winpcap.org/windump</a>), expect the padding.</p>
<p>Developers beware: all compilers may not pack structs alike. If a driver developer constructs their radiotap header with a packed structure, in order to ensure natural alignment, then it is important that they insert padding bytes by themselves.</p>
<p><b>AirPcap and Radiotap</b></p>
<p>The radiotap fields currently exported by AirPcap are the folowing:</p>
<ul>
<li>IEEE80211_RADIOTAP_FLAGS (unsigned 8-bit integer): Properties of transmitted and received frames. Unused at the moment.</li>
<li>IEEE80211_RADIOTAP_RATE (unsigned 8-bit integer): Data rate of the received frame, in multiples of 500kb/s.</li>
<li>IEEE80211_RADIOTAP_CHANNEL (2 unsigned 16-bit integers): Frequency of the channel the packet is received from, followed by flags (e.g. the modulation used for the transmission).</li>
<li>IEEE80211_RADIOTAP_LOCK_QUALITY (unsigned 16-bit integer): Signal Quality, in the range 0-100.</li>
<li>IEEE80211_RADIOTAP_ANTENNA (unsigned 8-bit integer): Unitless indication of the Rx/Tx antenna for this packet. The first antenna is antenna 0.</li>
<li>IEEE80211_RADIOTAP_DB_ANTSIGNAL (unsigned 8-bit integer): RF signal power at the antenna. Units are in dB above the noise floor.</li>
<li>IEEE80211_RADIOTAP_FCS (unsigned 32-bit integer): FCS from frame in network byte order. This Field is present only if the adapter is configured to include the 802.11 frame check sequence with <a class="el" href="group__airpcapfuncs.html#ga14cc811fb136709135e5fc7de26d2096">AirpcapSetFcsPresence()</a>.</li>
</ul>
<p>The best references for extracting and interpreting these fields are the developer's pack sample programs: both the <b>Capture_radio</b> and the <b>airpcap_and_libpcap</b> samples show how to decode the radiotap header and access the frame content after it.</p>
<p><b>How to Convert the Signal Power Returned by AirPcap into a dBm value?</b></p>
<p>This is a common question raised by developers that use AirPcap in their products.</p>
<p>The AirPcap signal strength information is in dB above the noise floor, therefore it's actually Signal to Noise Ratio information. If you assume that the noise floor is -95, which is in most cases a good assumption, then you can derive the absolute signal strength with the following formula:</p>
<p><code>DbmValue = DbValue - 95</code> </p>
</div>

<hr>
<p align="right"><font size="2">
<img border="0" src="../pics/cace_small.jpg" align="absbottom"> AirPcap documentation. Copyright (c) 2006-2008 
CACE Technologies, Inc. All rights reserved.</font></p>

			</td>
		</tr>
	</table>

    </BODY>
  </HTML>
